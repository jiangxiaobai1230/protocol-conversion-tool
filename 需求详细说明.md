# 需求详细说明

> **注意**：本文档是对`完整需求文档.md`的详细补充说明。所有内容与完整需求文档保持一致。

---

## 第一期详细需求

### 1. 知识库系统

#### 1.1 知识库数据结构详解

**知识库表结构**：
```sql
CREATE TABLE knowledge_base (
  id INT PRIMARY KEY AUTO_INCREMENT,
  target_header VARCHAR(255) NOT NULL,      -- 目标表头（唯一）
  protocol_field VARCHAR(255) NOT NULL,     -- 协议字段
  table_id VARCHAR(255),                    -- 来源表格ID（可选）
  confidence FLOAT DEFAULT 1.0,             -- 置信度
  label_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  labeler VARCHAR(255),                     -- 标注者ID
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY unique_mapping (target_header, protocol_field, table_id)
);
```

**实际例子**：
```
ID | target_header | protocol_field | table_id | confidence | label_time | labeler
1  | 协议名称      | 协议名         | supplier_001 | 1.0 | 2024-12-20 10:30:00 | user_001
2  | 入参          | 输入参数       | supplier_001 | 1.0 | 2024-12-20 10:35:00 | user_001
3  | 出参          | 输出参数       | supplier_001 | 1.0 | 2024-12-20 10:40:00 | user_001
4  | 数据类型      | 参数类型       | supplier_001 | 1.0 | 2024-12-20 10:45:00 | user_001
```

#### 1.2 知识库CRUD操作

**创建（Create）**：
```python
# 插入新的映射关系
INSERT INTO knowledge_base (target_header, protocol_field, table_id, confidence, labeler)
VALUES ("协议名称", "协议名", "supplier_001", 1.0, "user_001")
```

**查询（Read）**：
```python
# 按协议字段查询
SELECT * FROM knowledge_base WHERE protocol_field = "协议名"

# 按目标表头查询
SELECT * FROM knowledge_base WHERE target_header = "协议名称"

# 按来源查询
SELECT * FROM knowledge_base WHERE table_id = "supplier_001"

# 模糊查询
SELECT * FROM knowledge_base WHERE protocol_field LIKE "%参数%"
```

**更新（Update）**：
```python
# 更新置信度
UPDATE knowledge_base SET confidence = 0.95
WHERE protocol_field = "协议名" AND table_id = "supplier_001"
```

**删除（Delete）**：
```python
# 删除过期映射
DELETE FROM knowledge_base
WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR)
```

### 2. 人工匹配界面

#### 2.1 拖拽连线实现

**界面示例**：
```
左侧（协议字段）          右侧（目标表头）
┌─────────────────┐      ┌─────────────────┐
│ 协议名          │───→  │ 协议名称        │
│ 输入参数        │───→  │ 入参            │
│ 输出参数        │───→  │ 出参            │
│ 参数类型        │───→  │ 数据类型        │
│ 参数值          │      │ 参数值          │
└─────────────────┘      └─────────────────┘
```

**实现要求**：
- 使用Vue Draggable库
- 支持从左侧拖拽到右侧
- 支持删除连线
- 实时显示连线状态
- 保存映射关系到知识库

**数据结构**：
```javascript
mappings: [
  { from: "协议名", to: "协议名称" },
  { from: "输入参数", to: "入参" },
  { from: "输出参数", to: "出参" },
  { from: "参数类型", to: "数据类型" },
  { from: "参数值", to: "参数值" }
]
```

#### 2.2 人工匹配流程

**流程说明**：
```
1. 用户进入匹配页面
2. 系统加载协议字段列表和目标表头列表
3. 用户进行拖拽连线
4. 用户点击"保存映射关系"
5. 系统验证映射关系
6. 系统保存到知识库
7. 返回成功提示
```

### 3. Word文件导入功能

#### 3.1 文件上传和验证

**上传流程**：
```
1. 用户选择Word文件
2. 前端验证文件类型（.docx）
3. 前端验证文件大小（<50MB）
4. 后端接收文件
5. 后端验证文件格式
6. 生成唯一文件名
```

**文件验证**：
```python
import os
from datetime import datetime

def validate_and_copy_word_file(uploaded_file):
    """
    验证Word文件并复制到本地固定目录
    """

    # 1. 验证文件格式
    if not uploaded_file.filename.endswith('.docx'):
        raise ValueError("仅支持.docx格式的Word文件")

    # 2. 验证文件大小
    uploaded_file.seek(0, os.SEEK_END)
    file_size = uploaded_file.tell()
    if file_size > 50 * 1024 * 1024:  # 50MB
        raise ValueError("文件过大，请上传小于50MB的文件")

    # 3. 生成唯一文件名（带时间戳）
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"word_{timestamp}.docx"

    # 4. 定义本地保存目录
    upload_dir = "/data/uploads/"
    file_path = os.path.join(upload_dir, filename)

    # 5. 创建目录（如果不存在）
    os.makedirs(upload_dir, exist_ok=True)

    # 6. 复制文件到本地
    uploaded_file.seek(0)
    with open(file_path, 'wb') as f:
        f.write(uploaded_file.read())

    # 7. 验证文件完整性
    if not os.path.exists(file_path):
        raise ValueError("文件保存失败")

    # 8. 返回文件路径
    return {
        "status": "success",
        "filename": filename,
        "file_path": file_path,
        "file_size": file_size
    }
```

**实际例子**：
```
用户上传：protocol_test.docx（2.5MB）

系统处理：
1. 验证格式 → .docx ✓
2. 验证大小 → 2.5MB < 50MB ✓
3. 生成文件名 → word_20241220_103000.docx
4. 复制到目录 → /data/uploads/word_20241220_103000.docx
5. 验证完整性 → ✓
6. 返回 → /data/uploads/word_20241220_103000.docx

后续步骤使用这个本地文件路径进行处理
```

### 4. 表格识别功能

#### 4.1 表格识别实现

**表格识别流程**：
```python
from python_docx import Document

def extract_all_tables(word_file_path):
    """
    从Word文档中提取所有表格
    """
    doc = Document(word_file_path)
    tables_data = []

    for table_idx, table in enumerate(doc.tables):
        table_info = {
            "table_id": table_idx,
            "rows": len(table.rows),
            "cols": len(table.columns),
            "headers": [],
            "data": [],
            "format": "unknown"  # horizontal, vertical, mixed
        }

        # 1. 识别表头
        if len(table.rows) > 0:
            headers = [cell.text for cell in table.rows[0].cells]
            table_info["headers"] = headers

        # 2. 提取数据行
        for row_idx, row in enumerate(table.rows[1:]):
            row_data = [cell.text for cell in row.cells]
            table_info["data"].append(row_data)

        # 3. 判断表格格式
        table_info["format"] = detect_table_format(table)

        tables_data.append(table_info)

    return tables_data

def detect_table_format(table):
    """
    识别表格格式：横向、纵向或混合
    """
    rows = len(table.rows)
    cols = len(table.columns)

    # 横向表格：行数多于列数
    if rows > cols:
        return "horizontal"
    # 纵向表格：列数多于行数
    elif cols > rows:
        return "vertical"
    # 混合表格
    else:
        return "mixed"
```

**实际例子**：

横向表格识别：
```
输入表格：
| 协议名 | 输入参数 | 输出参数 |
|--------|---------|---------|
| 协议A  | 方法参数 | 返回值   |
| 协议B  | 入参     | 出参     |

输出：
{
  "table_id": 0,
  "rows": 3,
  "cols": 3,
  "headers": ["协议名", "输入参数", "输出参数"],
  "data": [
    ["协议A", "方法参数", "返回值"],
    ["协议B", "入参", "出参"]
  ],
  "format": "horizontal"
}
```

纵向表格识别：
```
输入表格：
| 属性 | 值 |
|------|-----|
| 协议名 | 协议A |
| 输入参数 | 方法参数 |
| 输出参数 | 返回值 |

输出：
{
  "table_id": 0,
  "rows": 4,
  "cols": 2,
  "headers": ["属性", "值"],
  "data": [
    ["协议名", "协议A"],
    ["输入参数", "方法参数"],
    ["输出参数", "返回值"]
  ],
  "format": "vertical"
}
```

### 5. 多表跨表数据读取

#### 5.1 多表识别和基本关联

**多表处理流程**：
```python
def process_multiple_tables(tables_data):
    """
    处理多个表格，进行基本的跨表关联
    """

    # 1. 识别所有表格
    table_count = len(tables_data)
    print(f"识别到 {table_count} 个表格")

    # 2. 按顺序读取表格数据
    all_data = []
    for table_info in tables_data:
        table_data = {
            "table_id": table_info["table_id"],
            "headers": table_info["headers"],
            "rows": table_info["data"],
            "format": table_info["format"]
        }
        all_data.append(table_data)

    # 3. 基本的表格关联（通过相同字段）
    merged_data = merge_tables_by_common_field(all_data)

    return merged_data

def merge_tables_by_common_field(all_data):
    """
    通过相同字段关联多个表格
    """
    if len(all_data) <= 1:
        return all_data[0]["rows"] if all_data else []

    # 找到公共字段
    headers1 = all_data[0]["headers"]
    headers2 = all_data[1]["headers"]
    common_fields = list(set(headers1) & set(headers2))

    if not common_fields:
        # 没有公共字段，直接拼接
        return concatenate_tables(all_data)

    # 通过公共字段进行关联
    merged = []
    for row1 in all_data[0]["rows"]:
        for row2 in all_data[1]["rows"]:
            # 检查公共字段是否匹配
            if match_rows(row1, row2, headers1, headers2, common_fields):
                # 合并行数据
                merged_row = row1 + row2
                merged.append(merged_row)

    return merged

def match_rows(row1, row2, headers1, headers2, common_fields):
    """
    检查两行是否通过公共字段匹配
    """
    for field in common_fields:
        idx1 = headers1.index(field)
        idx2 = headers2.index(field)
        if row1[idx1] != row2[idx2]:
            return False
    return True

def concatenate_tables(all_data):
    """
    直接拼接表格（没有公共字段时）
    """
    concatenated = []
    for table_data in all_data:
        concatenated.extend(table_data["rows"])
    return concatenated
```

**第一期实际例子**：

```
Word文档中有2个表格：

表格1（协议基本信息）：
| 协议名 | 版本 |
|--------|------|
| 协议A  | 1.0  |
| 协议B  | 2.0  |

表格2（协议详细信息）：
| 协议名 | 输入参数 | 输出参数 |
|--------|---------|---------|
| 协议A  | 方法参数 | 返回值   |
| 协议B  | 入参     | 出参     |

系统处理：
1. 识别2个表格
2. 识别公共字段："协议名"
3. 按"协议名"关联表格
4. 合并结果：
   [协议A, 1.0, 方法参数, 返回值]
   [协议B, 2.0, 入参, 出参]
```

### 6. 知识库查询功能

#### 6.1 查询场景

**场景1：精确查询**
```
输入：查询"协议名"的映射
查询SQL：SELECT * FROM knowledge_base WHERE protocol_field = "协议名"
结果：协议名 → 协议名称 (confidence: 1.0)
```

**场景2：按来源查询**
```
输入：查询来自"supplier_001"的所有映射
查询SQL：SELECT * FROM knowledge_base WHERE table_id = "supplier_001"
结果：
- 协议名 → 协议名称
- 输入参数 → 入参
- 输出参数 → 出参
```

**场景3：模糊查询**
```
输入：查询包含"参数"的映射
查询SQL：SELECT * FROM knowledge_base WHERE protocol_field LIKE "%参数%"
结果：
- 输入参数 → 入参
- 输出参数 → 出参
- 参数类型 → 数据类型
```

#### 6.2 查询性能优化

**索引策略**：
```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_protocol_field ON knowledge_base(protocol_field);
CREATE INDEX idx_target_header ON knowledge_base(target_header);
CREATE INDEX idx_table_id ON knowledge_base(table_id);
```

### 5. 数据输出与模板管理

#### 5.1 模板文件管理

**模板文件结构**：

标准模板文件（template.xlsx）：
```
| 序号 | 协议名称 | 入参 | 出参 | 数据类型 | 值域 | 单位 | 备注 |
|------|---------|------|------|---------|------|------|------|
| 1    | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] |
| 2    | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] | [待填充] |
| ...  | ...      | ...  | ...  | ...     | ...  | ...  | ...  |
```

**模板维护**：
- 模板文件保存在服务器
- 定期备份模板
- 支持多个模板版本
- 记录模板更新历史

#### 5.2 自动处理和数据填充

**自动处理流程**：
```
1. 用户导入Word文档（触发协议转换）
   ↓
2. 系统自动识别表格和数据
   ↓
3. 系统查询知识库进行字段映射
   ↓
4. 系统复制模板文件 → result_20241220_103000.xlsx
   ↓
5. 系统自动填充识别和映射的数据
   ↓
6. 系统自动保存输出文件
   ↓
7. 用户直接获得result_20241220_103000.xlsx（已完全填充）
```

**输出文件示例**：

result_20241220_103000.xlsx（已自动填充，用户可直接使用）：
```
| 序号 | 协议名称 | 入参 | 出参 | 数据类型 | 值域 | 单位 | 备注 |
|------|---------|------|------|---------|------|------|------|
| 1    | 协议A    | 方法参数 | 返回值 | 类型 | 0-100 | - | - |
| 2    | 协议B    | 入参 | 出参 | 数据类型 | -40~85 | ℃ | - |
```

#### 5.3 自动处理实现

**完整的处理代码**：
```python
import shutil
from datetime import datetime
from openpyxl import load_workbook
from python_docx import Document

def process_word_document(word_file_path):
    """
    自动处理Word文档：识别数据 → 复制模板 → 填充数据 → 保存结果
    """

    # 1. 识别Word文档中的数据
    doc = Document(word_file_path)
    recognized_data = extract_data_from_word(doc)

    # 2. 生成输出文件名（带时间戳，确保唯一）
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    result_file = f"result_{timestamp}.xlsx"

    # 3. 复制模板文件
    shutil.copy("template.xlsx", result_file)

    # 4. 加载复制的文件
    wb = load_workbook(result_file)
    ws = wb.active

    # 5. 填充识别的数据
    row = 2  # 从第2行开始（第1行是表头）
    for item in recognized_data:
        # 查询知识库进行字段映射
        mapped_data = query_knowledge_base(item)

        ws[f'B{row}'] = mapped_data['协议名称']
        ws[f'C{row}'] = mapped_data['入参']
        ws[f'D{row}'] = mapped_data['出参']
        ws[f'E{row}'] = mapped_data['数据类型']
        ws[f'F{row}'] = mapped_data['值域']
        ws[f'G{row}'] = mapped_data['单位']
        ws[f'H{row}'] = mapped_data['备注']
        row += 1

    # 6. 保存文件
    wb.save(result_file)

    # 7. 返回结果
    return {
        "status": "success",
        "message": "Word文档已自动处理并转换为Excel",
        "result_file": result_file,
        "data_count": len(recognized_data)
    }

def extract_data_from_word(doc):
    """从Word文档中提取表格数据"""
    data = []
    for table in doc.tables:
        for row in table.rows[1:]:  # 跳过表头
            row_data = [cell.text for cell in row.cells]
            data.append(row_data)
    return data

def query_knowledge_base(item):
    """查询知识库进行字段映射"""
    # 实现知识库查询逻辑
    pass
```

**文件位置和流程**：
- 模板文件：`template.xlsx`（保存在服务器，永不改变）
- 输入文件：用户导入的Word文档
- 输出文件：`result_YYYYMMDD_HHMMSS.xlsx`（自动生成，已填充）
- 用户获得：直接可用的Excel文件，无需任何手动操作

### 5. 错误处理和日志

#### 5.1 错误处理

**常见错误**：
```
错误1：文件格式不支持
处理：返回错误提示，建议使用CSV或Excel格式

错误2：知识库查询失败
处理：记录错误日志，返回用户友好的错误提示

错误3：数据验证失败
处理：标记该行数据，继续处理其他行
```

#### 5.2 日志系统

**日志级别**：
```
DEBUG：调试信息
INFO：一般信息
WARNING：警告信息
ERROR：错误信息
CRITICAL：严重错误
```

**日志示例**：
```
[2024-12-20 10:30:00] INFO: 用户user_001进入匹配页面
[2024-12-20 10:35:00] INFO: 用户保存映射关系：协议名 → 协议名称
[2024-12-20 10:40:00] WARNING: 知识库查询耗时150ms
[2024-12-20 10:45:00] ERROR: 文件上传失败，原因：文件过大
```

---

## 第二期详细需求

### 0. 大文件处理和前端不卡顿

#### 0.1 文件上传进度显示

**前端上传进度**：
```javascript
// 使用XMLHttpRequest或Fetch API的ProgressEvent
const xhr = new XMLHttpRequest();

xhr.upload.addEventListener('progress', (e) => {
    if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        updateProgressBar(percentComplete);
    }
});

xhr.addEventListener('load', () => {
    // 上传完成
    startProcessing();
});
```

#### 0.2 表格处理进度推送

**WebSocket实时进度推送**：
```python
from fastapi import WebSocket

@app.websocket("/ws/process/{file_id}")
async def websocket_process_progress(websocket: WebSocket, file_id: str):
    """
    WebSocket连接，实时推送表格处理进度
    """
    await websocket.accept()
    try:
        while True:
            progress = get_processing_progress(file_id)
            await websocket.send_json({
                "stage": progress["stage"],  # 识别表格、表格关联、字段映射等
                "percentage": progress["percentage"],
                "current": progress["current"],
                "total": progress["total"]
            })

            if progress["completed"]:
                break
            await asyncio.sleep(0.5)  # 每500ms推送一次
    finally:
        await websocket.close()
```

#### 0.3 手动输入匹配并保存到知识库

**手动输入接口**：
```python
@app.post("/api/manual-matching")
def save_manual_matching(protocol_field: str, target_header: str, table_id: str = None):
    """
    保存用户手动输入的匹配关系到知识库
    """
    # 验证输入
    if not protocol_field or not target_header:
        raise ValueError("协议字段和目标表头不能为空")

    # 保存到知识库
    mapping = KnowledgeBase(
        protocol_field=protocol_field,
        target_header=target_header,
        table_id=table_id,
        confidence=1.0,  # 手动输入的置信度为1.0
        labeler="user",
        label_time=datetime.now()
    )
    db.add(mapping)
    db.commit()

    return {
        "status": "success",
        "message": f"已保存：{protocol_field} → {target_header}"
    }
```

**批量手动输入**：
```python
@app.post("/api/batch-manual-matching")
def save_batch_manual_matching(matchings: List[Dict]):
    """
    批量保存用户手动输入的匹配关系

    输入格式：
    [
        {"protocol_field": "协议名", "target_header": "协议名称"},
        {"protocol_field": "输入参数", "target_header": "入参"},
        {"protocol_field": "输出参数", "target_header": "出参"}
    ]
    """
    results = []
    for matching in matchings:
        try:
            mapping = KnowledgeBase(
                protocol_field=matching["protocol_field"],
                target_header=matching["target_header"],
                confidence=1.0,
                labeler="user",
                label_time=datetime.now()
            )
            db.add(mapping)
            results.append({
                "status": "success",
                "protocol_field": matching["protocol_field"],
                "target_header": matching["target_header"]
            })
        except Exception as e:
            results.append({
                "status": "error",
                "protocol_field": matching["protocol_field"],
                "error": str(e)
            })

    db.commit()
    return {"results": results}
```

#### 0.4 拖拽操作防抖处理

**前端拖拽防抖**：
```javascript
// 使用防抖处理拖拽事件
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
    };
}

// 拖拽结束事件
const handleDragEnd = debounce((fromField, toHeader) => {
    // 异步保存到服务器
    saveMatching(fromField, toHeader);
}, 300);
```

### 1. 预处理模块

#### 1.1 文本标准化

**处理步骤**：
```
输入："  协议 名 称  "

步骤1：去除首尾空格
结果："协议 名 称"

步骤2：去除中间空格
结果："协议名称"

步骤3：统一小写
结果："协议名称"（中文不变）

步骤4：笔误修正
规则：形号→型号
结果："协议名称"

输出："协议名称"
```

**笔误修正规则**：
```python
correction_rules = {
    "形号": "型号",
    "参数名": "参数名称",
    "参数值": "参数值",
    # 可以继续添加更多规则
}
```

### 2. 向量生成模块

#### 2.1 ERNIE 3.0 Tiny模型

**模型特点**：
- 中文领域优化
- 模型体积约100M
- CPU推理耗时<10ms
- 对中文术语、缩略词、同义词的捕捉能力强

**向量生成示例**：
```
输入文本1："协议名"
输出向量1：[0.12, -0.45, 0.78, ..., 0.34]  (维度: 768)

输入文本2："协议名称"
输出向量2：[0.14, -0.43, 0.76, ..., 0.35]  (维度: 768)

输入文本3："协议标识"
输出向量3：[0.18, -0.40, 0.82, ..., 0.40]  (维度: 768)
```

#### 2.2 向量缓存

**缓存策略**：
```
第一次查询"协议名"：
1. 向量不在缓存中
2. 调用模型生成向量
3. 保存到缓存
4. 返回结果

第二次查询"协议名"：
1. 向量在缓存中
2. 直接返回缓存结果
3. 无需调用模型
```

### 3. 相似度计算

#### 3.1 余弦相似度计算

**计算公式**：
```
cos(θ) = (A · B) / (||A|| × ||B||)

其中：
- A · B：两个向量的点积
- ||A||：向量A的模
- ||B||：向量B的模
- 结果范围：0-1，1表示完全相同，0表示完全不同
```

**实际例子**：
```
向量1："协议名" → [0.12, -0.45, 0.78]
向量2："协议名称" → [0.14, -0.43, 0.76]

点积：0.12×0.14 + (-0.45)×(-0.43) + 0.78×0.76 = 0.9156
||向量1||：√(0.12² + 0.45² + 0.78²) = 0.8888
||向量2||：√(0.14² + 0.43² + 0.76²) = 0.8912

cos(θ) = 0.9156 / (0.8888 × 0.8912) = 0.92

相似度：0.92（非常高）
```

#### 3.2 批量相似度计算

**优化方案**：
```
使用矩阵运算而不是循环计算
- 将所有向量转换为矩阵形式
- 使用numpy进行批量计算
- 显著提高计算速度
```

### 4. 置信度判断

#### 4.1 阈值设定

**置信度分类**：
```
相似度 ≥ 0.7：高置信度
  ├─ 相似度 ≥ 0.9：非常高（可直接使用）
  ├─ 相似度 0.8-0.9：高（可使用）
  └─ 相似度 0.7-0.8：中等（可参考）

相似度 < 0.7：低置信度
  ├─ 相似度 0.5-0.7：较低（需要用户确认）
  └─ 相似度 < 0.5：很低（建议人工处理）
```

**实际例子**：
```
协议字段："协议标识"

相似度计算：
- vs "协议名称"：0.92 ✅ 高置信度
- vs "协议标识"：0.88 ✅ 高置信度
- vs "协议号"：0.68 ❌ 低置信度
- vs "名称"：0.58 ❌ 低置信度

结果：
- 推荐"协议标识"（相似度0.88，最高）
- 备选"协议名称"（相似度0.92，但不是最相似的）
```

### 5. 智能推荐功能

#### 5.1 推荐候选项排序

**排序规则**：
```
1. 按相似度从高到低排序
2. 同等相似度按知识库中的使用频率排序
3. 同等使用频率按最近使用时间排序
```

**推荐界面示例**：
```
协议字段：协议标识

系统推荐（按相似度排序）：
1. 协议标识    相似度 0.88 ⚠️ 低置信度
2. 协议名称    相似度 0.92 ✅ 高置信度
3. 协议号      相似度 0.68 ⚠️ 低置信度

解释：
- 第1个"协议标识"虽然相似度低，但可能是最准确的
- 第2个"协议名称"相似度高，但含义不同
- 用户需要仔细选择
```

### 6. 知识库优化

#### 6.1 用户反馈处理

**反馈类型**：
```
1. 反馈正确：用户确认推荐是正确的
   → 增加该映射的置信度

2. 反馈错误：用户修改了推荐
   → 记录错误的推荐
   → 保存用户的正确选择

3. 反馈不确定：用户不确定推荐是否正确
   → 标记为需要验证
   → 后续人工审核
```

#### 6.2 知识库更新

**更新流程**：
```
原条目：
- target_header: "协议名称"
- protocol_field: "协议名"
- confidence: 1.0

用户反馈（正确）：
- 增加使用计数
- 更新最后使用时间

用户反馈（错误）：
- 创建新条目：协议名 → 协议标识
- 标记原条目为可能不准确
```

### 7. 模型微调

#### 7.1 训练数据准备

**数据来源**：
- 第一期的所有人工标注数据
- 第二期用户的反馈数据

**数据格式**：
```
文本对：(协议字段, 目标表头)
标签：相似度分数（0-1）

示例：
("协议名", "协议名称") → 1.0  （完全匹配）
("协议名", "协议标识") → 0.65 （相似但不同）
("协议名", "参数值") → 0.15  （完全不同）
```

#### 7.2 微调过程

**微调步骤**：
```
1. 加载预训练的ERNIE 3.0 Tiny模型
2. 准备训练数据
3. 设置微调参数
   - 学习率：1e-5
   - 批大小：32
   - 训练轮数：3-5
4. 运行微调
5. 评估模型性能
6. 版本管理
```

---

## 性能指标详解

### 第一期性能指标

**知识库查询性能**：
```
单次查询：<50ms
批量查询（10条）：<100ms
```

**前端响应**：
```
拖拽操作：<100ms
页面加载：<1秒
```

### 第二期性能指标

**模型推理性能**：
```
单条向量生成：<5ms
单条相似度计算：<1ms
单条匹配总耗时：<10ms
```

**批量处理**：
```
批量处理（100条）：<1秒
```

---

## 数据验证

### 第一期数据验证

**知识库数据验证**：
- 检查target_header和protocol_field不为空
- 检查confidence在0-1之间
- 检查label_time有效
- 检查唯一性约束

**批量处理数据验证**：
- 检查文件格式正确
- 检查字段数量匹配
- 检查数据编码正确

### 第二期数据验证

**向量数据验证**：
- 检查向量维度正确（768）
- 检查向量值在有效范围内
- 检查相似度分数在0-1之间

**推荐数据验证**：
- 检查推荐候选项不为空
- 检查推荐排序正确
- 检查置信度判断正确

